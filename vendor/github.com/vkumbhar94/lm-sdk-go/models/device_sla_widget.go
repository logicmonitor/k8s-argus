// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DeviceSLAWidget device SLA widget
// swagger:model DeviceSLAWidget
type DeviceSLAWidget struct {
	dashboardIdField *int32

	descriptionField string

	idField int32

	intervalField int32

	lastUpdatedByField string

	lastUpdatedOnField int64

	nameField *string

	themeField string

	timescaleField string

	userPermissionField string

	// The services that should be used to compute the SLA, where each service should include serviceGroup and service
	BottomLabel string `json:"bottomLabel,omitempty"`

	// The threshold of color changes
	ColorThresholds []*ColorThreshold `json:"colorThresholds,omitempty"`

	// The days that SLA should be computed for, separated by commas. 1=Sunday, 2=Monday, 3=Tuesday, 4=Wednesday, 5=Thursday, 6=Friday, 7=Saturday.
	DaysInWeek string `json:"daysInWeek,omitempty"`

	// Whether or not selected metrics should be combined into one number (displayType:0) or should be displayed individually, up to four metrics (displayType:1)
	DisplayType int32 `json:"displayType,omitempty"`

	// The metrics (datapoints) that should be used to compute the SLA, where each service should include groupName (can be *), deviceName (can be *), dataSourceId or dataSourceFullName, instances (can be *), metric (datapoint), threshold, and exclusionSDTType (empty string means SDT periods will not be excluded, "group" means SDT periods at the device group level will be excluded, and "device" means SDT periods at the device level will be excluded)
	// Required: true
	Metrics []*SLAMetric `json:"metrics"`

	// The period during the selected days that the SLA should be computed for. * = all day, or a time range can be specified in the format of "hh:mm TO hh:mm", e.g. "01:15 TO 17:15"
	PeriodInOneDay string `json:"periodInOneDay,omitempty"`

	// The specific timezone for the widget
	Timezone string `json:"timezone,omitempty"`

	// Top list size for each point, 1 means aggregate
	TopX int32 `json:"topX,omitempty"`

	// How no data should be treated: 0 = unmonitored time will be ignored & subtracted from the total possible time, 1 = unmonitored time will be subtracted from uptime and counted as a violation, 2 = unmonitored time will be added to uptime and counted as available
	UnmonitoredTimeType int32 `json:"unmonitoredTimeType,omitempty"`
}

// DashboardID gets the dashboard Id of this subtype
func (m *DeviceSLAWidget) DashboardID() *int32 {
	return m.dashboardIdField
}

// SetDashboardID sets the dashboard Id of this subtype
func (m *DeviceSLAWidget) SetDashboardID(val *int32) {
	m.dashboardIdField = val
}

// Description gets the description of this subtype
func (m *DeviceSLAWidget) Description() string {
	return m.descriptionField
}

// SetDescription sets the description of this subtype
func (m *DeviceSLAWidget) SetDescription(val string) {
	m.descriptionField = val
}

// ID gets the id of this subtype
func (m *DeviceSLAWidget) ID() int32 {
	return m.idField
}

// SetID sets the id of this subtype
func (m *DeviceSLAWidget) SetID(val int32) {
	m.idField = val
}

// Interval gets the interval of this subtype
func (m *DeviceSLAWidget) Interval() int32 {
	return m.intervalField
}

// SetInterval sets the interval of this subtype
func (m *DeviceSLAWidget) SetInterval(val int32) {
	m.intervalField = val
}

// LastUpdatedBy gets the last updated by of this subtype
func (m *DeviceSLAWidget) LastUpdatedBy() string {
	return m.lastUpdatedByField
}

// SetLastUpdatedBy sets the last updated by of this subtype
func (m *DeviceSLAWidget) SetLastUpdatedBy(val string) {
	m.lastUpdatedByField = val
}

// LastUpdatedOn gets the last updated on of this subtype
func (m *DeviceSLAWidget) LastUpdatedOn() int64 {
	return m.lastUpdatedOnField
}

// SetLastUpdatedOn sets the last updated on of this subtype
func (m *DeviceSLAWidget) SetLastUpdatedOn(val int64) {
	m.lastUpdatedOnField = val
}

// Name gets the name of this subtype
func (m *DeviceSLAWidget) Name() *string {
	return m.nameField
}

// SetName sets the name of this subtype
func (m *DeviceSLAWidget) SetName(val *string) {
	m.nameField = val
}

// Theme gets the theme of this subtype
func (m *DeviceSLAWidget) Theme() string {
	return m.themeField
}

// SetTheme sets the theme of this subtype
func (m *DeviceSLAWidget) SetTheme(val string) {
	m.themeField = val
}

// Timescale gets the timescale of this subtype
func (m *DeviceSLAWidget) Timescale() string {
	return m.timescaleField
}

// SetTimescale sets the timescale of this subtype
func (m *DeviceSLAWidget) SetTimescale(val string) {
	m.timescaleField = val
}

// Type gets the type of this subtype
func (m *DeviceSLAWidget) Type() string {
	return "deviceSLA"
}

// SetType sets the type of this subtype
func (m *DeviceSLAWidget) SetType(val string) {

}

// UserPermission gets the user permission of this subtype
func (m *DeviceSLAWidget) UserPermission() string {
	return m.userPermissionField
}

// SetUserPermission sets the user permission of this subtype
func (m *DeviceSLAWidget) SetUserPermission(val string) {
	m.userPermissionField = val
}

// BottomLabel gets the bottom label of this subtype

// ColorThresholds gets the color thresholds of this subtype

// DaysInWeek gets the days in week of this subtype

// DisplayType gets the display type of this subtype

// Metrics gets the metrics of this subtype

// PeriodInOneDay gets the period in one day of this subtype

// Timezone gets the timezone of this subtype

// TopX gets the top x of this subtype

// UnmonitoredTimeType gets the unmonitored time type of this subtype

// UnmarshalJSON unmarshals this object with a polymorphic type from a JSON structure
func (m *DeviceSLAWidget) UnmarshalJSON(raw []byte) error {
	var data struct {

		// The services that should be used to compute the SLA, where each service should include serviceGroup and service
		BottomLabel string `json:"bottomLabel,omitempty"`

		// The threshold of color changes
		ColorThresholds []*ColorThreshold `json:"colorThresholds,omitempty"`

		// The days that SLA should be computed for, separated by commas. 1=Sunday, 2=Monday, 3=Tuesday, 4=Wednesday, 5=Thursday, 6=Friday, 7=Saturday.
		DaysInWeek string `json:"daysInWeek,omitempty"`

		// Whether or not selected metrics should be combined into one number (displayType:0) or should be displayed individually, up to four metrics (displayType:1)
		DisplayType int32 `json:"displayType,omitempty"`

		// The metrics (datapoints) that should be used to compute the SLA, where each service should include groupName (can be *), deviceName (can be *), dataSourceId or dataSourceFullName, instances (can be *), metric (datapoint), threshold, and exclusionSDTType (empty string means SDT periods will not be excluded, "group" means SDT periods at the device group level will be excluded, and "device" means SDT periods at the device level will be excluded)
		// Required: true
		Metrics []*SLAMetric `json:"metrics"`

		// The period during the selected days that the SLA should be computed for. * = all day, or a time range can be specified in the format of "hh:mm TO hh:mm", e.g. "01:15 TO 17:15"
		PeriodInOneDay string `json:"periodInOneDay,omitempty"`

		// The specific timezone for the widget
		Timezone string `json:"timezone,omitempty"`

		// Top list size for each point, 1 means aggregate
		TopX int32 `json:"topX,omitempty"`

		// How no data should be treated: 0 = unmonitored time will be ignored & subtracted from the total possible time, 1 = unmonitored time will be subtracted from uptime and counted as a violation, 2 = unmonitored time will be added to uptime and counted as available
		UnmonitoredTimeType int32 `json:"unmonitoredTimeType,omitempty"`
	}
	buf := bytes.NewBuffer(raw)
	dec := json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&data); err != nil {
		return err
	}

	var base struct {
		/* Just the base type fields. Used for unmashalling polymorphic types.*/

		DashboardID *int32 `json:"dashboardId"`

		Description string `json:"description,omitempty"`

		ID int32 `json:"id,omitempty"`

		Interval int32 `json:"interval,omitempty"`

		LastUpdatedBy string `json:"lastUpdatedBy,omitempty"`

		LastUpdatedOn int64 `json:"lastUpdatedOn,omitempty"`

		Name *string `json:"name"`

		Theme string `json:"theme,omitempty"`

		Timescale string `json:"timescale,omitempty"`

		Type string `json:"type"`

		UserPermission string `json:"userPermission,omitempty"`
	}
	buf = bytes.NewBuffer(raw)
	dec = json.NewDecoder(buf)
	dec.UseNumber()

	if err := dec.Decode(&base); err != nil {
		return err
	}

	var result DeviceSLAWidget

	result.dashboardIdField = base.DashboardID

	result.descriptionField = base.Description

	result.idField = base.ID

	result.intervalField = base.Interval

	result.lastUpdatedByField = base.LastUpdatedBy

	result.lastUpdatedOnField = base.LastUpdatedOn

	result.nameField = base.Name

	result.themeField = base.Theme

	result.timescaleField = base.Timescale

	if base.Type != result.Type() {
		/* Not the type we're looking for. */
		return errors.New(422, "invalid type value: %q", base.Type)
	}

	result.userPermissionField = base.UserPermission

	result.BottomLabel = data.BottomLabel

	result.ColorThresholds = data.ColorThresholds

	result.DaysInWeek = data.DaysInWeek

	result.DisplayType = data.DisplayType

	result.Metrics = data.Metrics

	result.PeriodInOneDay = data.PeriodInOneDay

	result.Timezone = data.Timezone

	result.TopX = data.TopX

	result.UnmonitoredTimeType = data.UnmonitoredTimeType

	*m = result

	return nil
}

// MarshalJSON marshals this object with a polymorphic type to a JSON structure
func (m DeviceSLAWidget) MarshalJSON() ([]byte, error) {
	var b1, b2, b3 []byte
	var err error
	b1, err = json.Marshal(struct {

		// The services that should be used to compute the SLA, where each service should include serviceGroup and service
		BottomLabel string `json:"bottomLabel,omitempty"`

		// The threshold of color changes
		ColorThresholds []*ColorThreshold `json:"colorThresholds,omitempty"`

		// The days that SLA should be computed for, separated by commas. 1=Sunday, 2=Monday, 3=Tuesday, 4=Wednesday, 5=Thursday, 6=Friday, 7=Saturday.
		DaysInWeek string `json:"daysInWeek,omitempty"`

		// Whether or not selected metrics should be combined into one number (displayType:0) or should be displayed individually, up to four metrics (displayType:1)
		DisplayType int32 `json:"displayType,omitempty"`

		// The metrics (datapoints) that should be used to compute the SLA, where each service should include groupName (can be *), deviceName (can be *), dataSourceId or dataSourceFullName, instances (can be *), metric (datapoint), threshold, and exclusionSDTType (empty string means SDT periods will not be excluded, "group" means SDT periods at the device group level will be excluded, and "device" means SDT periods at the device level will be excluded)
		// Required: true
		Metrics []*SLAMetric `json:"metrics"`

		// The period during the selected days that the SLA should be computed for. * = all day, or a time range can be specified in the format of "hh:mm TO hh:mm", e.g. "01:15 TO 17:15"
		PeriodInOneDay string `json:"periodInOneDay,omitempty"`

		// The specific timezone for the widget
		Timezone string `json:"timezone,omitempty"`

		// Top list size for each point, 1 means aggregate
		TopX int32 `json:"topX,omitempty"`

		// How no data should be treated: 0 = unmonitored time will be ignored & subtracted from the total possible time, 1 = unmonitored time will be subtracted from uptime and counted as a violation, 2 = unmonitored time will be added to uptime and counted as available
		UnmonitoredTimeType int32 `json:"unmonitoredTimeType,omitempty"`
	}{

		BottomLabel: m.BottomLabel,

		ColorThresholds: m.ColorThresholds,

		DaysInWeek: m.DaysInWeek,

		DisplayType: m.DisplayType,

		Metrics: m.Metrics,

		PeriodInOneDay: m.PeriodInOneDay,

		Timezone: m.Timezone,

		TopX: m.TopX,

		UnmonitoredTimeType: m.UnmonitoredTimeType,
	},
	)
	if err != nil {
		return nil, err
	}
	b2, err = json.Marshal(struct {
		DashboardID *int32 `json:"dashboardId"`

		Description string `json:"description,omitempty"`

		ID int32 `json:"id,omitempty"`

		Interval int32 `json:"interval,omitempty"`

		LastUpdatedBy string `json:"lastUpdatedBy,omitempty"`

		LastUpdatedOn int64 `json:"lastUpdatedOn,omitempty"`

		Name *string `json:"name"`

		Theme string `json:"theme,omitempty"`

		Timescale string `json:"timescale,omitempty"`

		Type string `json:"type"`

		UserPermission string `json:"userPermission,omitempty"`
	}{

		DashboardID: m.DashboardID(),

		Description: m.Description(),

		ID: m.ID(),

		Interval: m.Interval(),

		LastUpdatedBy: m.LastUpdatedBy(),

		LastUpdatedOn: m.LastUpdatedOn(),

		Name: m.Name(),

		Theme: m.Theme(),

		Timescale: m.Timescale(),

		Type: m.Type(),

		UserPermission: m.UserPermission(),
	},
	)
	if err != nil {
		return nil, err
	}

	return swag.ConcatJSON(b1, b2, b3), nil
}

// Validate validates this device SLA widget
func (m *DeviceSLAWidget) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDashboardID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateColorThresholds(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMetrics(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DeviceSLAWidget) validateDashboardID(formats strfmt.Registry) error {

	if err := validate.Required("dashboardId", "body", m.DashboardID()); err != nil {
		return err
	}

	return nil
}

func (m *DeviceSLAWidget) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name()); err != nil {
		return err
	}

	return nil
}

func (m *DeviceSLAWidget) validateColorThresholds(formats strfmt.Registry) error {

	if swag.IsZero(m.ColorThresholds) { // not required
		return nil
	}

	for i := 0; i < len(m.ColorThresholds); i++ {
		if swag.IsZero(m.ColorThresholds[i]) { // not required
			continue
		}

		if m.ColorThresholds[i] != nil {
			if err := m.ColorThresholds[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("colorThresholds" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *DeviceSLAWidget) validateMetrics(formats strfmt.Registry) error {

	if err := validate.Required("metrics", "body", m.Metrics); err != nil {
		return err
	}

	for i := 0; i < len(m.Metrics); i++ {
		if swag.IsZero(m.Metrics[i]) { // not required
			continue
		}

		if m.Metrics[i] != nil {
			if err := m.Metrics[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("metrics" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *DeviceSLAWidget) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DeviceSLAWidget) UnmarshalBinary(b []byte) error {
	var res DeviceSLAWidget
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
