// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"
	"io"
	"io/ioutil"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/validate"
)

// NetflowDataBase netflow data base
// swagger:discriminator NetflowDataBase dataType
type NetflowDataBase interface {
	runtime.Validatable

	// data type
	// Read Only: true
	DataType() string
	SetDataType(string)
}

type netflowDataBase struct {
	dataTypeField string
}

// DataType gets the data type of this polymorphic type
func (m *netflowDataBase) DataType() string {
	return "NetflowDataBase"
}

// SetDataType sets the data type of this polymorphic type
func (m *netflowDataBase) SetDataType(val string) {

}

// UnmarshalNetflowDataBaseSlice unmarshals polymorphic slices of NetflowDataBase
func UnmarshalNetflowDataBaseSlice(reader io.Reader, consumer runtime.Consumer) ([]NetflowDataBase, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []NetflowDataBase
	for _, element := range elements {
		obj, err := unmarshalNetflowDataBase(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalNetflowDataBase unmarshals polymorphic NetflowDataBase
func UnmarshalNetflowDataBase(reader io.Reader, consumer runtime.Consumer) (NetflowDataBase, error) {
	// we need to read this twice, so first into a buffer
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalNetflowDataBase(data, consumer)
}

func unmarshalNetflowDataBase(data []byte, consumer runtime.Consumer) (NetflowDataBase, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the dataType property.
	var getType struct {
		DataType string `json:"dataType"`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("dataType", "body", getType.DataType); err != nil {
		return nil, err
	}

	// The value of dataType is used to determine which type to create and unmarshal the data into
	switch getType.DataType {
	case "NetflowDataBase":
		var result netflowDataBase
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "application":
		var result NetflowApplication
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "bandwidth":
		var result NetflowBandwidth
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "groupFlowRecord":
		var result GroupNetFlowRecord
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "qosReportTableRow":
		var result NetflowQoSReportTableRow
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	}
	return nil, errors.New(422, "invalid dataType value: %q", getType.DataType)

}

// Validate validates this netflow data base
func (m *netflowDataBase) Validate(formats strfmt.Registry) error {
	return nil
}
