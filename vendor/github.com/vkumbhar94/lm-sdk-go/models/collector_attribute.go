// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"bytes"
	"encoding/json"
	"io"
	"io/ioutil"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/validate"
)

// CollectorAttribute collector attribute
// swagger:discriminator CollectorAttribute name
type CollectorAttribute interface {
	runtime.Validatable

	// name
	// Required: true
	Name() string
	SetName(string)
}

type collectorAttribute struct {
	nameField string
}

// Name gets the name of this polymorphic type
func (m *collectorAttribute) Name() string {
	return "CollectorAttribute"
}

// SetName sets the name of this polymorphic type
func (m *collectorAttribute) SetName(val string) {

}

// UnmarshalCollectorAttributeSlice unmarshals polymorphic slices of CollectorAttribute
func UnmarshalCollectorAttributeSlice(reader io.Reader, consumer runtime.Consumer) ([]CollectorAttribute, error) {
	var elements []json.RawMessage
	if err := consumer.Consume(reader, &elements); err != nil {
		return nil, err
	}

	var result []CollectorAttribute
	for _, element := range elements {
		obj, err := unmarshalCollectorAttribute(element, consumer)
		if err != nil {
			return nil, err
		}
		result = append(result, obj)
	}
	return result, nil
}

// UnmarshalCollectorAttribute unmarshals polymorphic CollectorAttribute
func UnmarshalCollectorAttribute(reader io.Reader, consumer runtime.Consumer) (CollectorAttribute, error) {
	// we need to read this twice, so first into a buffer
	data, err := ioutil.ReadAll(reader)
	if err != nil {
		return nil, err
	}
	return unmarshalCollectorAttribute(data, consumer)
}

func unmarshalCollectorAttribute(data []byte, consumer runtime.Consumer) (CollectorAttribute, error) {
	buf := bytes.NewBuffer(data)
	buf2 := bytes.NewBuffer(data)

	// the first time this is read is to fetch the value of the name property.
	var getType struct {
		Name string `json:"name"`
	}
	if err := consumer.Consume(buf, &getType); err != nil {
		return nil, err
	}

	if err := validate.RequiredString("name", "body", getType.Name); err != nil {
		return nil, err
	}

	// The value of name is used to determine which type to create and unmarshal the data into
	switch getType.Name {
	case "CollectorAttribute":
		var result collectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "GcpBillingCollectorAttributeV2":
		var result GcpBillingCollectorAttributeV2
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "GcpComputeServiceLimitsCollectorAttributeV2":
		var result GcpComputeServiceLimitsCollectorAttributeV2
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "GcpStackDriverCollectorAttributeV2":
		var result GcpStackDriverCollectorAttributeV2
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "aggregate":
		var result AggragateCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "awsautoscalingservicelimits":
		var result AwsAutoScalingServiceLimitsCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "awsbilling":
		var result AwsBillingCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "awsbillingreport":
		var result AwsBillingReportCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "awsclassicelbservicelimits":
		var result AwsClassicElbServiceLimitsCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "awscloudwatch":
		var result AwsCloudWatchCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "awsdynamodb":
		var result AwsDynamodbCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "awsec2reservedinstance":
		var result AwsEC2ReservedInstanceCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "awsec2reservedinstancecoverage":
		var result AwsEC2ReservedInstanceCoverageCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "awsec2scheduledevents":
		var result AwsEC2ScheduledEventsCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "awsec2servicelimits":
		var result AwsEc2ServiceLimitsCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "awsecsservicedetails":
		var result AwsEcsServiceDetailsCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "awss3":
		var result AwsS3CollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "awsservicelimitsfromtrustedadvisor":
		var result AwsServiceLimitsFromTrustedAdvisorCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "awssesservicelimits":
		var result AwsSesServiceLimitsCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "awssqs":
		var result AwsSqsCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "azurebilling":
		var result AzureBillingCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "azureinsights":
		var result AzureInsightsCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "azurenetworkservicelimits":
		var result AzureNetworkServiceLimitsCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "azureresourcehealth":
		var result AzureResourceHealthCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "azurestorageservicelimits":
		var result AzureStorageServiceLimitsCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "azurevmservicelimits":
		var result AzureVMServiceLimitsCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "batchscript":
		var result BatchScriptCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "cim":
		var result CIMCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "datapump":
		var result DataPumpCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "dns":
		var result DNSCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "esx":
		var result ESXCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "internal":
		var result InternalCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "ipmi":
		var result IPMICollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "jdbc":
		var result JDBCCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "jmx":
		var result JMXCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "memcached":
		var result MemcachedCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "mongo":
		var result MongoCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "netapp":
		var result NetAppCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "perfmon":
		var result PerfmonCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "ping":
		var result PingCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "script":
		var result ScriptCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "sdkscript":
		var result SDKScriptCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "snmp":
		var result SNMPCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "tcp":
		var result TCPCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "udp":
		var result UDPCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "webpage":
		var result WebPageCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "wmi":
		var result WMICollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	case "xen":
		var result XENCollectorAttribute
		if err := consumer.Consume(buf2, &result); err != nil {
			return nil, err
		}
		return &result, nil

	}
	return nil, errors.New(422, "invalid name value: %q", getType.Name)

}

// Validate validates this collector attribute
func (m *collectorAttribute) Validate(formats strfmt.Registry) error {
	return nil
}
